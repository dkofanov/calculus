#include "lib/matrix.h"
#include "../1/lib/analytic_function.h"
#include <iostream>
#include <sstream>

using namespace cmath;

constexpr size_t n = 12;

void SolveIterations(const Matrix<n, n, MatrixType::ROW_BASED, AFunction>  &m,
                     const Vector<n, AFunction> &f);

void SolveGauss(const Matrix<n, n, MatrixType::ROW_BASED, AFunction>  &m,
                const Vector<n, AFunction> &f);

int main() {
    Matrix<n, n, MatrixType::ROW_BASED, AFunction> m;

    m.Initialize({
        1 ,0.3333333333333333 ,0.25 ,0.2 ,0.16666666666666666 ,0.14285714285714285 ,0.125 ,0.1111111111111111 ,0.1 ,0.09090909090909091 ,0.08333333333333333 ,0.07692307692307693 ,
0.2 ,1 ,0.14285714285714285 ,0.125 ,0.1111111111111111 ,0.1 ,0.09090909090909091 ,0.08333333333333333 ,0.07692307692307693 ,0.07142857142857142 ,0.06666666666666667 ,0.0625 ,
0.1 ,0.09090909090909091 ,1 ,0.07692307692307693 ,0.07142857142857142 ,0.06666666666666667 ,0.0625 ,0.058823529411764705 ,0.05555555555555555 ,0.05263157894736842 ,0.05 ,0.047619047619047616 ,
0.058823529411764705 ,0.05555555555555555 ,0.05263157894736842 ,1 ,0.047619047619047616 ,0.045454545454545456 ,0.043478260869565216 ,0.041666666666666664 ,0.04 ,0.038461538461538464 ,0.037037037037037035 ,0.03571428571428571 ,
0.038461538461538464 ,0.037037037037037035 ,0.03571428571428571 ,0.034482758620689655 ,1 ,0.03225806451612903 ,0.03125 ,0.030303030303030304 ,0.029411764705882353 ,0.02857142857142857 ,0.027777777777777776 ,0.02702702702702703 ,
0.02702702702702703 ,0.02631578947368421 ,0.02564102564102564 ,0.025 ,0.024390243902439025 ,1 ,0.023255813953488372 ,0.022727272727272728 ,0.022222222222222223 ,0.021739130434782608 ,0.02127659574468085 ,0.020833333333333332 ,
0.02 ,0.0196078431372549 ,0.019230769230769232 ,0.018867924528301886 ,0.018518518518518517 ,0.01818181818181818 ,1 ,0.017543859649122806 ,0.017241379310344827 ,0.01694915254237288 ,0.016666666666666666 ,0.01639344262295082 ,
0.015384615384615385 ,0.015151515151515152 ,0.014925373134328358 ,0.014705882352941176 ,0.014492753623188406 ,0.014285714285714285 ,0.014084507042253521 ,1 ,0.0136986301369863 ,0.013513513513513514 ,0.013333333333333334 ,0.013157894736842105 ,
0.012195121951219513 ,0.012048192771084338 ,0.011904761904761904 ,0.011764705882352941 ,0.011627906976744186 ,0.011494252873563218 ,0.011363636363636364 ,0.011235955056179775 ,1 ,0.01098901098901099 ,0.010869565217391304 ,0.010752688172043012 ,
0.009900990099009901 ,0.00980392156862745 ,0.009708737864077669 ,0.009615384615384616 ,0.009523809523809525 ,0.009433962264150943 ,0.009345794392523364 ,0.009259259259259259 ,0.009174311926605505 ,1 ,0.009009009009009009 ,0.008928571428571428 ,
0.00819672131147541 ,0.008130081300813009 ,0.008064516129032258 ,0.008 ,0.007936507936507936 ,0.007874015748031496 ,0.0078125 ,0.007751937984496124 ,0.007692307692307693 ,0.007633587786259542 ,1 ,0.007518796992481203 ,
0.006896551724137931 ,0.00684931506849315 ,0.006802721088435374 ,0.006756756756756757 ,0.006711409395973154 ,0.006666666666666667 ,0.006622516556291391 ,0.006578947368421052 ,0.006535947712418301 ,0.006493506493506494 ,0.0064516129032258064 ,1
});

    Vector<n, AFunction> f;
    f.Initialize({
        1.0 ,0.5 ,0.3333333333333333 ,0.25 ,0.2 ,0.16666666666666666 ,0.14285714285714285 ,0.125 ,0.1111111111111111 ,0.1 ,0.09090909090909091 ,0.08333333333333333
    });


    SolveGauss(m, f);
    SolveIterations(m, f);


    return 0;
}

void SolveGauss(const Matrix<n, n, MatrixType::ROW_BASED, AFunction>  &m,
                const Vector<n, AFunction> &f)
{
    std::cout << "-----------------------------\n";
    std::cout << "GaussElimination:" << std::endl;
    auto sol = m.SolveGauss(f);
    auto x = sol.GetAnsVector();
    auto residual = (m * x) - f;
    std::cout << "\nans:\n" << x << std::endl;
    std::cout << "\nresidual:\n" << residual.Norm<NormType::MAX_ABS>() << std::endl;
    std::cout << "-----------------------------\n" << std::endl;
}

void SolveIterations(const Matrix<n, n, MatrixType::ROW_BASED, AFunction>  &m,
                     const Vector<n, AFunction> &f)
{
    std::cout << "-----------------------------\n";
    std::cout << "SimpleIterations:" << std::endl;
    auto sol = m.SolveIterations<1000000>(f, 1.e-16);
    auto x = sol.GetAnsVector();
    auto residual = (m * x) - f;
    std::cout << "\nans:\n" << x << std::endl;
    std::cout << "\nresidual:\n" << residual.Norm<NormType::MAX_ABS>() << std::endl;
    std::cout << "\niterations num:\n" << sol.GetNumIterations() << std::endl;
    std::cout << "-----------------------------\n" << std::endl;
}